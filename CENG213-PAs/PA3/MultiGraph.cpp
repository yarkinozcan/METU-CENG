#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//

GraphEdge   MultiGraph::getEdge(const std::string& vertexFromName,
                        const std::string& vertexToName,const std::string& edgeName){
                            bool a=false;
                            bool b=false;
                            int s;
                            int t;
                            for(int i=0;i<vertexList.size();i++){
                                if(vertexList[i].name==vertexFromName){
                                    s=i;
                                    a=true;
                                }
                                if(vertexList[i].name==vertexToName){
                                    t=i;
                                    b=true;
                                }
                            }
                            if(a&&b){
                                for(int i=0;i<vertexList[s].edges.size();i++){
                                    if(vertexList[s].edges[i].name==edgeName&&vertexList[s].edges[i].endVertexIndex==t){
                                        return vertexList[s].edges[i];
                                    }
                                }
                            }
                        }
bool        MultiGraph::edgeExists(const std::string& vertexFromName,
                        const std::string& vertexToName,const std::string& edgeName){
                            bool a=false;
                            bool b=false;
                            int s;
                            int t;
                            for(int i=0;i<vertexList.size();i++){
                                if(vertexList[i].name==vertexFromName){
                                    s=i;
                                    a=true;
                                }
                                if(vertexList[i].name==vertexToName){
                                    t=i;
                                    b=true;
                                }
                            }
                            if(a&&b){
                                for(int i=0;i<vertexList[s].edges.size();i++){
                                    if(vertexList[s].edges[i].name==edgeName&&vertexList[s].edges[i].endVertexIndex==t){
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }
bool        MultiGraph::vertexExists(const std::string& vertexFromName,
                        const std::string& vertexToName) const{
                            bool a=false;
                            bool b=false;
                            int s;
                            int t;
                            for(int i=0;i<vertexList.size();i++){
                                if(vertexList[i].name==vertexFromName){
                                    s=i;
                                    a=true;
                                }
                                if(vertexList[i].name==vertexToName){
                                    t=i;
                                    b=true;
                                }
                            }
                            if(a&&b){
                                return true;
                            }
                            else{
                                return false;
                            }
                        }
int MultiGraph::getIndex(const std::string& vertexName) const{
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName){
            return i;
        }
    }
}

 std::vector<GraphVertex> MultiGraph::getList() const{
     return vertexList;
 }
 
 bool        MultiGraph::vertex1Exists(const std::string& vertexName) const{
     for(int i=0;i<vertexList.size();i++){
         if(vertexList[i].name==vertexName){
             return true;
         }
     }
     return false;
 }
                    
                        
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    return w0*(1-alpha)+w1*alpha;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName){
            throw DuplicateVertexException(vertexName);
        }
    }
    GraphVertex newVertex;
    newVertex.name=vertexName;
    vertexList.push_back(newVertex);
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName){
            for(int j=0;j<vertexList.size();j++){
                for(int l=0;l<vertexList[j].edges.size();l++){
                    if(vertexList[j].edges[l].endVertexIndex==i){
                        vertexList[j].edges.erase(vertexList[j].edges.begin()+l);
                    }
                }
            }
            vertexList.erase(vertexList.begin()+i);
            return;
        }
    }
    throw VertexNotFoundException(vertexName);
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    bool a=false;
    bool b=false;
    int f;
    int t;
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexToName){
            t=i;
            a=true;
        }
        if(vertexList[i].name==vertexFromName){
            b=true;
            f=i;
        }
    }
    if(a&&b){
        for(int i=0;i<vertexList[f].edges.size();i++){
            if(edgeName==vertexList[f].edges[i].name){
                if(vertexList[f].edges[i].endVertexIndex==t){
                    throw SameNamedEdgeException(edgeName,vertexList[f].name,vertexList[t].name);
                }
            }
        }
        GraphEdge newEdge;
        newEdge.name=edgeName;
        newEdge.weight[0]=weight0;
        newEdge.weight[1]=weight1;
        newEdge.endVertexIndex=t;
        vertexList[f].edges.push_back(newEdge);
    }
    else{
        if(a&&!b){
            throw VertexNotFoundException(vertexFromName);
        }
        else if(!a&&b){
            throw VertexNotFoundException(vertexToName);
        }
        else{
            throw VertexNotFoundException(vertexFromName);
        }
    }
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    bool a=false;
    bool b=false;
    bool c=true;
    int f;
    int t;
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexToName){
            t=i;
            a=true;
        }
        if(vertexList[i].name==vertexFromName){
            b=true;
            f=i;
        }
    }
    if(a&&b){
        for(int i=0;i<vertexList[f].edges.size();i++){
            if(edgeName==vertexList[f].edges[i].name){
                if(vertexList[f].edges[i].endVertexIndex==t){
                    vertexList[f].edges.erase(vertexList[f].edges.begin()+i);
                    c=false;
                }
            }
        }
        if(c){
            throw EdgeNotFoundException(vertexFromName,edgeName);
        }
    }
    else{
        if(a&&!b){
            throw VertexNotFoundException(vertexFromName);
        }
        else if(!a&&b){
            throw VertexNotFoundException(vertexToName);
        }
        else{
            throw VertexNotFoundException(vertexFromName);
        }
    }
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    bool a=false;
    bool b=false;
    int s;
    int t;
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexNameTo){
            a=true;
            t=i;
        }
        if(vertexList[i].name==vertexNameFrom){
            b=true;
            s=i;
        }
    }
    if(a&&b){
        GraphVertex dummy2;
        int y;
        std::vector<Pair<float, int>> dist;
        std::vector<Pair<int,int>> prev;
        Pair<int,int> dummy;
        dummy.key=-1;
        dummy.value=-1;
        for(int i=0;i<vertexList.size();i++){
            Pair<float, int> temp;
            temp.key=99999999;
            temp.value=i;
            dist.push_back(temp);
            prev.push_back(dummy);
        }
        dist[s].key=0;
        std::priority_queue<Pair<float, int>,
                                        std::vector<Pair<float, int>>,
                                        GreaterComparator<Pair<float, int>>> q;
        for(int i=0;i<vertexList.size();i++){
            q.push(dist[i]);
        }
        while(!q.empty()){
            y=q.top().value;
            q.pop();
            for(int i=0;i<vertexList[y].edges.size();i++){
                float new_dist=dist[y].key+Lerp(vertexList[y].edges[i].weight[0],vertexList[y].edges[i].weight[1],heuristicWeight);
                if(new_dist<dist[vertexList[y].edges[i].endVertexIndex].key){
                    dist[vertexList[y].edges[i].endVertexIndex].key=new_dist;
                    prev[vertexList[y].edges[i].endVertexIndex].key=y;
                    prev[vertexList[y].edges[i].endVertexIndex].value=i;
                    std::priority_queue<Pair<float, int>,
                                        std::vector<Pair<float, int>>,
                                        GreaterComparator<Pair<float, int>>> q2;
                    while(!q.empty()){
                        if(q.top().value!=vertexList[y].edges[i].endVertexIndex){
                            q2.push(q.top());
                        }
                        q.pop();
                    }
                    q2.push(dist[vertexList[y].edges[i].endVertexIndex]);
                    q=q2;
                }
            }
        }
        if(prev[t].key==-1){
            return false;
        }
        else{
            std::vector<int> reversed;
            int k=t;
            while(k!=s){
                reversed.push_back(k);
                reversed.push_back(prev[k].value);
                k=prev[k].key;
            }
            reversed.push_back(k);
            for(int i=1;i<=reversed.size();i++){
                orderedVertexEdgeIndexList.push_back(reversed[reversed.size()-i]);
            }
        }
    }
    else{
        if(a&&!b){
            throw VertexNotFoundException(vertexNameFrom);
        }
        else if(!a&&b){
            throw VertexNotFoundException(vertexNameTo);
        }
        else{
            throw VertexNotFoundException(vertexNameFrom);
        }
    }
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    bool a=false;
    bool b=false;
    int s;
    int t;
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexNameTo){
            a=true;
            t=i;
        }
        if(vertexList[i].name==vertexNameFrom){
            b=true;
            s=i;
        }
    }
    if(a&&b){
        GraphVertex dummy2;
        int y;
        std::vector<Pair<float, int>> dist;
        std::vector<Pair<int,int>> prev;
        Pair<int,int> dummy;
        dummy.key=-1;
        dummy.value=-1;
        for(int i=0;i<vertexList.size();i++){
            Pair<float, int> temp;
            temp.key=99999999;
            temp.value=i;
            dist.push_back(temp);
            prev.push_back(dummy);
        }
        dist[s].key=0;
        std::priority_queue<Pair<float, int>,
                                        std::vector<Pair<float, int>>,
                                        GreaterComparator<Pair<float, int>>> q;
        for(int i=0;i<vertexList.size();i++){
            q.push(dist[i]);
        }
        while(!q.empty()){
            y=q.top().value;
            q.pop();
            for(int i=0;i<vertexList[y].edges.size();i++){
                bool u=true;
                for(int k=0;k<edgeNames.size();k++){
                    if(vertexList[y].edges[i].name==edgeNames[k]){
                        u=false;
                    }
                }
                if(u){
                    float new_dist=dist[y].key+Lerp(vertexList[y].edges[i].weight[0],vertexList[y].edges[i].weight[1],heuristicWeight);
                    if(new_dist<dist[vertexList[y].edges[i].endVertexIndex].key){
                        dist[vertexList[y].edges[i].endVertexIndex].key=new_dist;
                        prev[vertexList[y].edges[i].endVertexIndex].key=y;
                        prev[vertexList[y].edges[i].endVertexIndex].value=i;
                        std::priority_queue<Pair<float, int>,
                                            std::vector<Pair<float, int>>,
                                            GreaterComparator<Pair<float, int>>> q2;
                        while(!q.empty()){
                            if(q.top().value!=vertexList[y].edges[i].endVertexIndex){
                                q2.push(q.top());
                            }
                            q.pop();
                        }
                        q2.push(dist[vertexList[y].edges[i].endVertexIndex]);
                        q=q2;
                    }
                }
            }
        }
        if(prev[t].key==-1){
            return false;
        }
        else{
            std::vector<int> reversed;
            int k=t;
            while(k!=s){
                reversed.push_back(k);
                reversed.push_back(prev[k].value);
                k=prev[k].key;
            }
            reversed.push_back(k);
            for(int i=1;i<=reversed.size();i++){
                orderedVertexEdgeIndexList.push_back(reversed[reversed.size()-i]);
            }
        }
    }
    else{
        if(a&&!b){
            throw VertexNotFoundException(vertexNameFrom);
        }
        else if(!a&&b){
            throw VertexNotFoundException(vertexNameTo);
        }
        else{
            throw VertexNotFoundException(vertexNameFrom);
        }
    }
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    int count=0;
    for(int i=0;i<vertexList.size();i++){
        for(int k=0;k<vertexList[i].edges.size();k++){
            for(int l=0;l<vertexList[vertexList[i].edges[k].endVertexIndex].edges.size();l++){
                if(vertexList[vertexList[i].edges[k].endVertexIndex].edges[l].endVertexIndex==i&&vertexList[vertexList[i].edges[k].endVertexIndex].edges[l].name==vertexList[i].edges[k].name){
                    count++;
                }
            }
        }
    }
    return count/2;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    /*int s;
    bool a=false;
    bool c;
    for(int i=0;i<vertexList.size();i++){
        if(vertexList[i].name==vertexName){
            s=i;
            a=true;
        }
    }
    if(a){
        int count=0;
        Pair<int,int> dummy;
        dummy.key=0;
        dummy.value=s;
        std::priority_queue<Pair<int, int>,
                                            std::vector<Pair<int, int>>,
                                            LessComparator<Pair<int, int>>> q;
        q.push(dummy);
        std::vector<int> visited;
        while(!q.empty()){
            dummy=q.top();
            q.pop();
            visited.push_back(dummy.value);
            if(count<dummy.key){
                count=dummy.key;
            }
            for(int i=0;i<vertexList[dummy.value].edges.size();i++){
                c=true;
                for(int k=0;k<visited.size();k++){
                    if(vertexList[dummy.value].edges[i].endVertexIndex==visited[k]){
                        c=false;
                    }
                }
                if(c){
                    if(vertexList[dummy.value].edges[i].name==edgeName){
                        Pair<int,int> dummy2; 
                        dummy2.key=dummy.key+1;
                        dummy2.value=vertexList[dummy.value].edges[i].endVertexIndex;
                        q.push(dummy2);
                    }
                }
            }
        }
        return count;
    }
    else{
        throw VertexNotFoundException(vertexName);
    }
    */
    if(vertex1Exists(vertexName)){
        int l=0;
        int s=getIndex(vertexName);
        std::vector<int> prev;
        std::vector<int> dist;
        for(int i=0;i<vertexList.size();i++){
            dist.push_back(-1);
            prev.push_back(-1);
        }
        dist[s]=0;
        Pair<int,int> dummy;
        dummy.key=l;
        dummy.value=s;
        std::priority_queue<Pair<int, int>,
                                            std::vector<Pair<int, int>>,
                                            GreaterComparator<Pair<int, int>>> q;
        q.push(dummy);
        while(!q.empty()){
            dummy=q.top();
            q.pop();
            for(int i=0;i<vertexList[dummy.value].edges.size();i++){
                if(vertexList[dummy.value].edges[i].name==edgeName&&dist[vertexList[dummy.value].edges[i].endVertexIndex]==-1){
                    Pair<int,int> newlyAdded;
                    prev[vertexList[dummy.value].edges[i].endVertexIndex]=dummy.value;
                    dist[vertexList[dummy.value].edges[i].endVertexIndex]=dist[dummy.value]+1;
                    newlyAdded.key=dist[dummy.value]+1;
                    newlyAdded.value=vertexList[dummy.value].edges[i].endVertexIndex;
                    q.push(newlyAdded);
                }
            }
        }
        int distance=0;
        for(int i=0;i<dist.size();i++){
            if(distance<dist[i]){
                distance=dist[i];
            }
        }
        return distance;
    }
    else{
        throw VertexNotFoundException(vertexName);
    }
    
    
    
    
    
    
    
}